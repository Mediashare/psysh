# Psysh Project Analysis Summary (Generated by Gemini)

This document provides a high-level technical and structural overview of the Psysh project to guide future development.

## Key Technologies

- **Language**: PHP
- **Dependency Management**: Composer
- **Core Components**:
  - `nikic/php-parser`: For Abstract Syntax Tree (AST) parsing and code transformation. This is central to Psysh's functionality.
  - `symfony/console`: Powers the interactive command-line interface (CLI).
  - `symfony/var-dumper`: For rich, colorized output of variables.
- **Quality Assurance**:
  - **Testing**: PHPUnit (`test/` directory).
  - **Static Analysis**: PHPStan and Phan.
  - **Code Style**: StyleCI.

## Core Architecture

Psysh is a modular, object-oriented application with a clear separation of concerns.

- **`Shell.php`**: The main application class that orchestrates the entire Read-Eval-Print-Loop (REPL).
- **`CodeCleaner/`**: A vital component that processes user input. It uses a series of "passes" (AST visitors) to validate, transform, and prepare code for execution (e.g., adding implicit `return` statements).
- **`Command/`**: Contains all the built-in commands like `ls`, `doc`, `history`, and `wtf`. This is the primary entry point for adding new user-facing functionality. Each command extends the base Symfony Command class.
- **`Configuration.php`**: A central object holding all shell configuration, such as casters, matchers, colors, and history settings.
- **`ExecutionLoop/`**: Manages the actual code execution, often forking processes to prevent fatal errors from crashing the main shell.
- **`Readline/` & `TabCompletion/`**: Handle user input, history, and tab-completion logic, with multiple backends for different system environments.

## How to Contribute

- **Adding a New Command**:
  1. Create a new class in `src/Command/` that extends `Psy\Command\Command`.
  2. Implement the `configure()` and `execute()` methods.
  3. The command will be auto-registered by the shell.
  4. Add a corresponding test case in `test/Command/`.

- **Modifying Code Parsing**:
  1. Create a new pass in `src/CodeCleaner/` that extends `Psy\CodeCleaner\CodeCleanerPass`.
  2. Implement the `NodeVisitor` interface methods (e.g., `leaveNode`) to modify the AST.
  3. Register the new pass in the `CodeCleaner` service.
  4. Add relevant tests to cover the new transformation logic.

- **Profiling**:
  1. The `profile` command uses `xhprof` or `Xdebug` to profile code.
  2. The command is located in `src/Command/ProfileCommand.php`.
  3. The command now executes code directly via `Shell::execute`, ensuring the most accurate possible profiling context by using PsySH's own evaluation engine.
  4. This method preserves the entire session context, including variables, user-defined classes, functions, and autoloaders.
  5. The command parses the `xhprof` or `Xdebug` output to display a summary table.
  6. See [PROFILING.md](PROFILING.md) for more details.

- **ProfileCommand implement rules**:
  1. La commande profile a des options (--flag) et prend en argument un CodeArgument (une ou plusieurs lignes de code php). Son but est de profiler l'execution du code donné en argument à la commande profile. 
  2. TOUT le contexte php du shell psysh (historique, autoload, class, functions, variables créer et ou modifier) doit être partagé lors de l'execution du code donné à la commande profilage peut importe la solution utilisée, ex: eval(), Process(), sub Psy\Shell(). Cela veut dire qu'il doit être possible de créer une class/function à partir de psysh et de lancer la commande profile avec du code utilisant cette class/function, de cette manière les logs du profilage contiennes tous les calls de functions (incluant les appels à la class/function de provenance du shell psysh) sans surplus (ex: les calls de fonctions de psysh ne devant pas être logger).
  3. Il faut trouver une solution pour executer un profilage précis et complet du code exécuter donné en argument de la commande profile. Je dois avoir les logs précis de tous les appels de function custom et native à php. Exclure les logs subtentiels du resultat si la méthode l'exige.
  4. Différentes méthodes ont étés testées:
    - La méthode par évaluation (`eval()`). 
      - Positifs: rapidité d'execution.
      - Négatifs: n'est pas précis dans le résultat du profilage, ne contient qu'une ligne (étant le call correspondant à l'éval() et ne rentre pas dans le détail).
    - La méthode par sub shell Psysh.
      - Positifs: Le code exécuter dans le sous shell psysh contient facilement le même contexte php que le main process psysh. Dans les résultats de profilage il y a bien une cohérence entre les logs de profilage et le code exécuté.
      - Négatifs: Contient des calls de fonction psysh dans le résultat du profilage. Ceux-ci ne devant pas être présent logiquement. Solution possible serait d'avoir un filtrage performant sur les calls à afficher dans le profilage, en vérifiant que l'execution de chaque calls provient bien uniquement du contexte d'execution de CodeArgument.
    - La méthode par sub Process Symfony.
      - Positifs: @TODO for AI assistant, make a tests and respond to this question
      - Négatifs: @TODO for AI assistant, make a tests and respond to this question
    - La méthode fichier php temporaire.
      - Positifs: @TODO for AI assistant, make a tests and respond to this question
      - Négatifs: @TODO for AI assistant, make a tests and respond to this question
  5. Si tu utilise la serialization afin de partager le contexte PHP entre 2 exécutions de code alors il faut que cette solution fonctionne avec toutes les closures possibles. Pas d'exception de closure ne pouvant être serializé à part pour problème de sécurité ou une closure synthaxiquement erronée ne pouvant être serializé par exemple.
  6. Dans le résultat du profilage doit contenir uniquement les traces utiles.
